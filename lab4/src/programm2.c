#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс завершен\n");
        exit(0);
    } else if (pid > 0) {
        // Родительский процесс
        printf("Родительский процесс продолжает работу\n");
        sleep(10);
        printf("Родительский процесс завершен\n");
    } else {
        // Ошибка при создании процесса
        printf("Ошибка при создании процесса\n");
        exit(1);
    }
    return 0;
}

/*
Зомби-процессы в операционной системе появляются, когда процесс завершается, но его родительский процесс не вызывает функцию wait() или waitpid() для получения статуса завершения дочернего процесса. В этом случае дочерний процесс продолжает занимать системные ресурсы, но не может быть управляем родительским процессом. Зомби-процессы не являются активными процессами, но они могут накапливаться и занимать ресурсы системы, что может привести к проблемам с производительностью.
Для создания зомби-процесса в языке C можно использовать функцию fork() для создания дочернего процесса, а затем завершить его с помощью функции exit() без вызова wait() или waitpid() в родительском процессе. Пример кода для создания зомби-процесса:
c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс завершен\n");
        exit(0);
    } else if (pid > 0) {
        // Родительский процесс
        printf("Родительский процесс продолжает работу\n");
        sleep(10);
        printf("Родительский процесс завершен\n");
    } else {
        // Ошибка при создании процесса
        printf("Ошибка при создании процесса\n");
        exit(1);
    }
    return 0;
}

Для проверки наличия зомби-процессов в системе можно использовать команду ps aux | grep Z, которая выведет список всех зомби-процессов.
Чтобы избавиться от зомби-процессов, необходимо вызвать функцию wait() или waitpid() в родительском процессе для получения статуса завершения дочернего процесса. Это позволит освободить системные ресурсы, занимаемые зомби-процессом. Если родительский процесс не может завершиться, можно использовать команду kill -9 <pid> для принудительного завершения процесса. Однако, это может привести к потере данных и другим проблемам, поэтому следует использовать эту команду только в крайних случаях.
*/